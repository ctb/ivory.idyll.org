<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.4: http://docutils.sourceforge.net/" />
<title>Wrapping C/C++ for Python</title>
<style type="text/css">

/*
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:Date: $Date: 2005-12-18 01:56:14 +0100 (Sun, 18 Dec 2005) $
:Revision: $Revision: 4224 $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left {
  clear: left }

img.align-right {
  clear: right }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;
  background-color: #eeeeee }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

tt.docutils {
  background-color: #eeeeee }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="wrapping-c-c-for-python">
<h1 class="title">Wrapping C/C++ for Python</h1>
<p>There are a number of options if you want to wrap existing C or C++
functionality in Python.</p>
<div class="section">
<h1><a id="manual-wrapping" name="manual-wrapping">Manual wrapping</a></h1>
<p>If you have a relatively small amount of C/C++ code to wrap, you can
do it by hand.  The <a class="reference" href="http://docs.python.org/ext/ext.html">Extending and Embedding</a> section of the docs is a pretty
good reference.</p>
<p>When I write wrappers for C and C++ code, I usually provide a procedural
interface to the code and then use Python to construct an object-oriented
interface.  I do things this way for two reasons: first, exposing C++
objects to Python is a pain; and second, I prefer writing higher-level
structures in Python to writing them in C++.</p>
<p>Let's take a look at a basic wrapper: we have a function 'hello' in a
file 'hello.c'.  'hello' is defined like so:</p>
<pre class="literal-block">
char * hello(char * what)
</pre>
<p>To wrap this manually, we need to do the following.</p>
<p>First, write a Python-callable function that takes in a string and returns
a string.</p>
<pre class="literal-block">
static PyObject * hello_wrapper(PyObject * self, PyObject * args)
{
  char * input;
  char * result;
  PyObject * ret;

  // parse arguments
  if (!PyArg_ParseTuple(args, &quot;s&quot;, &amp;input)) {
    return NULL;
  }

  // run the actual function
  result = hello(input);

  // build the resulting string into a Python object.
  ret = PyString_FromString(result);
  free(result);

  return ret;
}
</pre>
<p>Second, register this function within a module's symbol table (all Python
functions live in a module, even if they're actually C functions!)</p>
<pre class="literal-block">
static PyMethodDef HelloMethods[] = {
 { &quot;hello&quot;, hello_wrapper, METH_VARARGS, &quot;Say hello&quot; },
 { NULL, NULL, 0, NULL }
};
</pre>
<p>Third, write an init function for the module (all extension modules require
an init function).</p>
<pre class="literal-block">
DL_EXPORT(void) inithello(void)
{
  Py_InitModule(&quot;hello&quot;, HelloMethods);
}
</pre>
<p>Fourth, write a setup.py script:</p>
<pre class="literal-block">
from distutils.core import setup, Extension

# the c++ extension module
extension_mod = Extension(&quot;hello&quot;, [&quot;hellomodule.c&quot;, &quot;hello.c&quot;])

setup(name = &quot;hello&quot;, ext_modules=[extension_mod])
</pre>
<p>There are two aspects of this code that are worth discussing, even
at this simple level.</p>
<p>First, error handling: note the PyArg_ParseTuple call.  That call
is what tells Python that the 'hello' wrapper function takes precisely
one argument, a string (&quot;s&quot; means &quot;string&quot;; &quot;ss&quot; would mean &quot;two strings&quot;;
&quot;si&quot; would mean &quot;string and integer&quot;).  The convention in the C API to Python
is that a NULL return from a function that returns PyObject* indicates
an error has occurred; in this case, the error information is set
within PyArg_ParseTuple and we're just passing the error on up the stack
by returning NULL.</p>
<p>Second, references.  Python works on a system of reference counting:
each time a function &quot;takes ownership&quot; of an object (by, for example,
assigning it to a list, or a dictionary) it increments that object's
reference count by one using Py_INCREF.  When the object is removed
from use in that particular place (e.g. removed from the list or
dictionary), the reference count is decremented with Py_DECREF.  When
the reference count reaches 0, Python knows that this object is not
being used by anything and can be freed (it may not be freed immediately,
however).</p>
<p>Why does this matter?  Well, we're creating a PyObject in this code,
with PyString_FromString.  Do we need to INCREF it?  To find out,
go take a look at the documentation for PyString_FromString:</p>
<blockquote>
<a class="reference" href="http://docs.python.org/api/stringObjects.html#l2h-461">http://docs.python.org/api/stringObjects.html#l2h-461</a></blockquote>
<p>See where it says &quot;New reference&quot;?  That means it's handing back an
object with a reference count of 1, and that's what we want.  If it
had said &quot;Borrowed reference&quot;, then we would need to INCREF the object
before returning it, to indicate that we wanted the allocated memory to
survive past the end of the function.</p>
<p>Here's a way to think about references:</p>
<blockquote>
<ul class="simple">
<li>if you receive a Python object from the Python API, you can use it
within your own C code without INCREFing it.</li>
<li>if you want to guarantee that the Python object survives past the
end of your own C code, you must INCREF it.</li>
<li>if you received an object from Python code and it was a new reference,
but you don't want it to survive past the end of your own C code, you
should DECREF it.</li>
</ul>
</blockquote>
<p>If you wanted to return None, by the way, you can use Py_None.  Remember
to INCREF it!</p>
<p>Another note: during the class, I talked about using PyCObjects to
pass opaque C/C++ data types around.  This is useful if you are using
Python to organize your code, but you have complex structures that you
don't need to be Python-accessible.  You can wrap pointers in
PyCObjects (with an associated destructor, if so desired) at which
point they become opaque Python objects whose memory is managed by the
Python interpreter.  You can see an example in the example code, under
<tt class="docutils literal"><span class="pre">code/hello/hellmodule.c</span></tt>, functions <tt class="docutils literal"><span class="pre">cobj_in</span></tt>, <tt class="docutils literal"><span class="pre">cobj_out</span></tt>, and
<tt class="docutils literal"><span class="pre">free_my_struct</span></tt>, which pass an allocated C structure back to Python
using a PyCObject wrapper.</p>
<p>So that's a brief introduction to how you wrap things by hand.</p>
<p>As you might guess, however, there are a number of projects devoted
to automatically wrapping code.  Here's a brief introduction to some of
them.</p>
<!-- CTB: talk about testing c code with python? -->
<!-- Also pointers, deallocators.  (khmer?) -->
</div>
<div class="section">
<h1><a id="wrapping-python-code-with-swig" name="wrapping-python-code-with-swig">Wrapping Python code with SWIG</a></h1>
<p>SWIG stands for &quot;Simple Wrapper Interface Generator&quot;, and it is
capable of wrapping C in a large variety of languages.  To quote,
&quot;SWIG is used with different types of languages including common
scripting languages such as Perl, PHP, Python, Tcl, Ruby and PHP. The
list of supported languages also includes non-scripting languages such
as C#, Common Lisp (CLISP, Allegro CL, CFFI, UFFI), Java, Modula-3 and
OCAML. Also several interpreted and compiled Scheme implementations
(Guile, MzScheme, Chicken) are supported.&quot;</p>
<p>Whew.</p>
<p>But we only care about Python for now!</p>
<p>SWIG is essentially a macro language that groks C code and can spit
out wrapper code for your language of choice.</p>
<p>You'll need three things for a SWIG wrapping of our 'hello' program.
First, a Makefile:</p>
<pre class="literal-block">
all:
     swig -python -c++ -o _swigdemo_module.cc swigdemo.i
     python setup.py build_ext --inplace
</pre>
<p>This shows the steps we need to run: first, run SWIG to generate
the C code extension; then run <tt class="docutils literal"><span class="pre">setup.py</span> <span class="pre">build</span></tt> to actually build it.</p>
<p>Second, we need a SWIG wrapper file, 'swigdemo.i'.  In this case, it
can be pretty simple:</p>
<pre class="literal-block">
%module swigdemo

%{
#include &lt;stdlib.h&gt;
#include &quot;hello.h&quot;
%}

%include &quot;hello.h&quot;
</pre>
<p>A few things to note: the %module specifies the name of the module
to be generated from this wrapper file.  The code between the
%{ %} is placed, verbatim, in the C output file; in this case it
just includes two header files.  And, finally, the last line, %include,
just says &quot;build your interface against the declarations in this header
file&quot;.</p>
<p>OK, and third, we will need a setup.py.  This is virtually identical
to the setup.py we wrote for the manual wrapping:</p>
<pre class="literal-block">
from distutils.core import setup, Extension

extension_mod = Extension(&quot;_swigdemo&quot;, [&quot;_swigdemo_module.cc&quot;, &quot;hello.c&quot;])

setup(name = &quot;swigdemo&quot;, ext_modules=[extension_mod])
</pre>
<p>Now, when we run 'make', swig will generate the _swigdemo_module.cc
file, as well as a 'swigdemo.py' file; then, setup.py will compile the
two C files together into a single shared library, '_swigdemo', which
is imported by swigdemo.py; then the user can just 'import swigdemo'
and have direct access to everything in the wrapped module.</p>
<p>Note that swig can wrap most simple types &quot;out of the box&quot;.  It's only
when you get into your own types that you will have to worry about providing
what are called &quot;typemaps&quot;; I can show you some examples.</p>
<p>I've also heard (from someone in the class) that SWIG is essentially
not supported any more, so buyer beware.  (I will also say that SWIG
is pretty crufty.  When it works and does exactly what you want, your
life is good.  Fixing bugs in it is messy, though, as is adding new
features, because it's a template language, and hence many of the
constructs are ad hoc.)</p>
</div>
<div class="section">
<h1><a id="wrapping-c-code-with-pyrex" name="wrapping-c-code-with-pyrex">Wrapping C code with pyrex</a></h1>
<p>pyrex, as I discussed yesterday, is a weird hybrid of C and Python
that's meant for generating fast Python-esque code.  I'm not sure I'd
call this &quot;wrapping&quot;, but ... here goes.</p>
<p>First, write a .pyx file; in this case, I'm calling it 'hellomodule.pyx',
instead of 'hello.pyx', so that I don't get confused with 'hello.c'.</p>
<pre class="literal-block">
cdef extern from &quot;hello.h&quot;:
    char * hello(char *s)

def hello_fn(s):
    return hello(s)
</pre>
<p>What the 'cdef' says is, &quot;grab the symbol 'hello' from the file
'hello.h'&quot;.  Then you just go ahead and define your 'hello_fn' as
you would if it were Python.</p>
<p>and... that's it.  You've still got to write a setup.py, of course:</p>
<pre class="literal-block">
from distutils.core import setup
from distutils.extension import Extension
from Pyrex.Distutils import build_ext

setup(
  name = &quot;hello&quot;,
  ext_modules=[ Extension(&quot;hellomodule&quot;, [&quot;hellomodule.pyx&quot;, &quot;hello.c&quot;]) ],
  cmdclass = {'build_ext': build_ext}
)
</pre>
<p>but then you can just run 'setup.py build_ext --inplace' and you'll be able
to 'import hellomodule; hellomodule.hello_fn'.</p>
</div>
<div class="section">
<h1><a id="ctypes" name="ctypes">ctypes</a></h1>
<p>In Python 2.5, the ctypes module is included.  This module lets you
talk directly to shared libraries on both Windows and UNIX, which is
pretty darned handy.  But can it be used to call our C code directly?</p>
<p>The answer is yes, with a caveat or two.</p>
<p>First, you need to compile 'hello.c' into a shared library.</p>
<pre class="literal-block">
gcc -o hello.so -shared -fPIC hello.c
</pre>
<p>Then, you need to tell the system where to find the shared library.</p>
<pre class="literal-block">
export LD_LIBRARY_PATH=.
</pre>
<p>Now you can load the library with ctypes:</p>
<pre class="literal-block">
from ctypes import cdll

hello_lib = cdll.LoadLibrary(&quot;hello.so&quot;)
hello = hello_lib.hello
</pre>
<p>So far, so good -- now what happens if you run it?</p>
<pre class="literal-block">
&gt;&gt; print hello(&quot;world&quot;)
136040696
</pre>
<p>Whoops!  You still need to tell Python/ctypes what kind of return
value to expect!  In this case, we're expecting a char pointer:</p>
<pre class="literal-block">
from ctypes import c_char_p
hello.restype = c_char_p
</pre>
<p>And now it will work:</p>
<blockquote>
&gt;&gt; print hello(&quot;world&quot;)
hello, world</blockquote>
<p>Voila!</p>
<p>I should say that ctypes is not intended for this kind of wrapping,
because of the whole LD_LIBRARY_PATH setting requirement.  That is,
it's really intended for accessing <em>system</em> libraries.  But you can
still use it for other stuff like this.</p>
</div>
<div class="section">
<h1><a id="sip" name="sip">SIP</a></h1>
<p>SIP is the tool used to generate Python bindings for Qt (PyQt), a graphics
library.  However, it can be used to wrap any C or C++ API.</p>
<p>As with SWIG, you have to start with a definition file.  In this case,
it's pretty easy: just put this in 'hello.sip':</p>
<pre class="literal-block">
%CModule hellomodule 0

char * hello(char *);
</pre>
<p>Now you need to write a 'configure' script:</p>
<pre class="literal-block">
import os
import sipconfig

# The name of the SIP build file generated by SIP and used by the build
# system.
build_file = &quot;hello.sbf&quot;

# Get the SIP configuration information.
config = sipconfig.Configuration()

# Run SIP to generate the code.
os.system(&quot; &quot;.join([config.sip_bin, &quot;-c&quot;, &quot;.&quot;, &quot;-b&quot;, build_file, &quot;hello.sip&quot;]))

# Create the Makefile.
makefile = sipconfig.SIPModuleMakefile(config, build_file)

# Add the library we are wrapping.  The name doesn't include any platform
# specific prefixes or extensions (e.g. the &quot;lib&quot; prefix on UNIX, or the
# &quot;.dll&quot; extension on Windows).
makefile.extra_libs = [&quot;hello&quot;]
makefile.extra_lib_dirs = [&quot;.&quot;]

# Generate the Makefile itself.
makefile.generate()
</pre>
<p>Now, run 'configure.py', and then run 'make' on the generated Makefile,
and your extension will be compiled.</p>
<p>(At this point I should say that I haven't really used SIP before, and I
feel like it's much more powerful than this example would show you!)</p>
</div>
<div class="section">
<h1><a id="boost-python" name="boost-python">Boost.Python</a></h1>
<p>If you are an expert C++ programmer and want to wrap a lot of C++ code,
I would recommend taking a look at the Boost.Python library, which
lets you run C++ code from Python, and Python code from C++, seamlessly.
I haven't used it at all, and it's too complicated to cover in a short
period!</p>
<p><a class="reference" href="http://www.boost-consulting.com/writing/bpl.html">http://www.boost-consulting.com/writing/bpl.html</a></p>
</div>
<div class="section">
<h1><a id="recommendations" name="recommendations">Recommendations</a></h1>
<p>Based on my little survey above, I would suggest using SWIG to write
wrappers for relatively small libraries, while SIP probably provides a
more manageable infrastructure for wrapping large libraries (which I
know I did not demonstrate!)</p>
<p>Pyrex is astonishingly easy to use, and it may be a good option if you
have a small library to wrap.  My guess is that you would spend a lot
of time converting types back and forth from C/C++ to Python, but I could
be wrong.</p>
<p>ctypes is excellent if you have a bunch of functions to run and you don't
care about extracting complex data types from them: you just want to pass
around the encapsulated data types between the functions in order to
accomplish a goal.</p>
</div>
<div class="section">
<h1><a id="one-or-two-more-notes-on-wrapping" name="one-or-two-more-notes-on-wrapping">One or two more notes on wrapping</a></h1>
<p>As I said at the beginning, I tend to write procedural interfaces to
my C++ code and then use Python to wrap them in an object-oriented
interface.  This lets me adjust the OO structure of my code more
flexibly; on the flip side, I only use the code from Python, so I
really don't care what the C++ code looks like as long as it runs fast
;).  So, you might find it worthwhile to invest in figuring out how to
wrap things in a more object-oriented manner.</p>
<p>Secondly, one of the biggest benefits I find from wrapping my C code in
Python is that all of a sudden I can test it pretty easily.  Testing is
something you <em>do not</em> want to do in C, because you have to declare all
the variables and stuff that you use, and that just gets in the way of
writing simple tests.  I find that once I've wrapped something in Python,
it becomes much more testable.</p>
</div>
</div>
</body>
</html>
