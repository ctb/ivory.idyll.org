<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.4: http://docutils.sourceforge.net/" />
<title>pyparsing</title>
<style type="text/css">

/*
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:Date: $Date: 2005-12-18 01:56:14 +0100 (Sun, 18 Dec 2005) $
:Revision: $Revision: 4224 $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left {
  clear: left }

img.align-right {
  clear: right }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;
  background-color: #eeeeee }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

tt.docutils {
  background-color: #eeeeee }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="pyparsing">
<h1 class="title">pyparsing</h1>
<div class="section">
<h1><a id="basic-pyparsing" name="basic-pyparsing">Basic pyparsing</a></h1>
<div class="section">
<h2><a id="matching-text" name="matching-text">Matching text</a></h2>
<pre class="doctest-block">
&gt;&gt;&gt; import pyparsing
&gt;&gt;&gt; from pyparsing import Word, printables, Literal, StringEnd, Optional
&gt;&gt;&gt; grammar = Literal(&quot;Hello,&quot;) + Word(printables)
&gt;&gt;&gt; print grammar.parseString(&quot;Hello, nurse!&quot;)
['Hello,', 'nurse!']
</pre>
<p>So that's easy enough.  But here, we <em>know</em> that 'Hello' is going to be
there -- we're really only interested in the word <em>after</em> 'Hello'.</p>
<pre class="doctest-block">
&gt;&gt;&gt; grammar = Literal(&quot;Hello,&quot;).suppress() + Word(printables)
&gt;&gt;&gt; print grammar.parseString(&quot;Hello, nurse!&quot;)
['nurse!']
</pre>
<p>Let's break things down a bit:</p>
<pre class="doctest-block">
&gt;&gt;&gt; article = Word(printables)
&gt;&gt;&gt; grammar = Literal(&quot;Hello,&quot;).suppress() + article
&gt;&gt;&gt; print grammar.parseString(&quot;Hello, nurse!&quot;)
['nurse!']
</pre>
<p>Wouldn't it be nice to give the article (&quot;nurse!&quot;) a name?</p>
<pre class="doctest-block">
&gt;&gt;&gt; article = Word(printables).setResultsName(&quot;the_article&quot;)
&gt;&gt;&gt; grammar = Literal(&quot;Hello,&quot;).suppress() + article
&gt;&gt;&gt; results = grammar.parseString(&quot;Hello, nurse!&quot;)
</pre>
<p>Now, given this, you can do two things: you can either refer to the result
as an element of a list,</p>
<pre class="doctest-block">
&gt;&gt;&gt; print results[0]
nurse!
</pre>
<p>or by name:</p>
<pre class="doctest-block">
&gt;&gt;&gt; print results.the_article
nurse!
</pre>
<p>This kind of naming is incredibly handy and it's one of the main reasons
I chose pyparsing.  For example, let's try out more complicated example:</p>
<pre class="doctest-block">
&gt;&gt;&gt; article = Word(printables).setResultsName(&quot;the_article&quot;)
&gt;&gt;&gt; salutation = (Literal(&quot;Hello,&quot;) | Literal(&quot;Goodbye,&quot;)).suppress()
&gt;&gt;&gt; adjective = Word(printables).setResultsName('adjective')
&gt;&gt;&gt; grammar = ((salutation + adjective + article) | \
...            (salutation + article)) + StringEnd()
</pre>
<p>This can match &quot;Hello, nurse!&quot;:</p>
<pre class="doctest-block">
&gt;&gt;&gt; results_1 = grammar.parseString(&quot;Hello, nurse!&quot;)
</pre>
<p>as well as &quot;Goodbye, cruel world!&quot;:</p>
<pre class="doctest-block">
&gt;&gt;&gt; results_2 = grammar.parseString(&quot;Goodbye, cruel world!&quot;)
</pre>
<p>but in <em>both</em> cases you can extract <tt class="docutils literal"><span class="pre">the_article</span></tt> by name:</p>
<pre class="doctest-block">
&gt;&gt;&gt; print results_1.the_article
nurse!
&gt;&gt;&gt; print results_2.the_article
world!
</pre>
<p>And, of course, the <tt class="docutils literal"><span class="pre">adjective</span></tt> result is only set in the case where it
was matched:</p>
<pre class="doctest-block">
&gt;&gt;&gt; print results_1.adjective
&lt;BLANKLINE&gt;
&gt;&gt;&gt; print results_2.adjective
cruel
</pre>
<p>Note that this was not a particularly good example; rather than writing
the grammer like so:</p>
<pre class="doctest-block">
&gt;&gt;&gt; grammar = ((salutation + adjective + article) | \
...            (salutation + article)) + StringEnd()
</pre>
<p>I could have written it like this:</p>
<pre class="doctest-block">
&gt;&gt;&gt; grammar = salutation + Optional(adjective) + article + StringEnd()
</pre>
</div>
<div class="section">
<h2><a id="interlude-whitespace-drives-tokenizing" name="interlude-whitespace-drives-tokenizing">Interlude: whitespace drives tokenizing</a></h2>
<p>I've studiously avoided talking about removing that final '!' from
&quot;Hello, nurse!&quot; until now, and that's because it's not this simple:</p>
<pre class="literal-block">
article = Word(printables) + &quot;!&quot;
print article.parseString(&quot;nurse!&quot;)
</pre>
<p>You see, the '+' operator (a.k.a. <tt class="docutils literal"><span class="pre">pyparsing.And</span></tt>) only joins <em>tokens</em>,
and pyparsing implicitly tokenizes on <em>whitespace</em>.  So <em>this</em> would work,</p>
<pre class="doctest-block">
&gt;&gt;&gt; article = Word(printables) + &quot;!&quot;
&gt;&gt;&gt; print article.parseString(&quot;nurse !&quot;)
['nurse', '!']
</pre>
<p>because now you're parsing 'Word AND !'.</p>
<p>(The only way I know of to remove that '!' is to use a parse action:</p>
<pre class="doctest-block">
&gt;&gt;&gt; def remove_exclamation(x):
...    return x[0].rstrip('!')
&gt;&gt;&gt; article = Word(printables)
&gt;&gt;&gt; article = article.setParseAction(remove_exclamation)
&gt;&gt;&gt; print article.parseString(&quot;nurse!&quot;)
['nurse']
</pre>
<p>More about parse actions later.)</p>
<p>Bottom line: tokenizing on whitespace makes a lot of things easier, and
some things harder; I guess it's a good thing...</p>
</div>
<div class="section">
<h2><a id="skipto" name="skipto">SkipTo</a></h2>
<p>Suppose you have an annoying section of text that you want to just
jump past and not parse:</p>
<pre class="doctest-block">
&gt;&gt;&gt; annoying = &quot;&quot;&quot;
... SOMETHING
... SOMETHING ELSE
... END
... MORE STUFF THAT MATTERS
... &quot;&quot;&quot;
</pre>
<p>This is easily handled with SkipTo:</p>
<pre class="doctest-block">
&gt;&gt;&gt; from pyparsing import SkipTo
&gt;&gt;&gt; end_marker = SkipTo(&quot;END&quot;, include=True).suppress()
&gt;&gt;&gt; (end_marker + &quot;MORE STUFF THAT MATTERS&quot;).parseString(annoying)
(['MORE STUFF THAT MATTERS'], {})
</pre>
</div>
<div class="section">
<h2><a id="regex-matches" name="regex-matches">Regex matches</a></h2>
<p>You can do regular expression matches too:</p>
<pre class="doctest-block">
&gt;&gt;&gt; from pyparsing import Regex
&gt;&gt;&gt; hex_num = Regex(&quot;[0-9a-fA-F]+&quot;)
&gt;&gt;&gt; hex_num.parseString(&quot;1f&quot;)
(['1f'], {})
</pre>
</div>
<div class="section">
<h2><a id="lists-and-more" name="lists-and-more">Lists and more</a></h2>
<p>Suppose we want to allow matches to multiple hex numbers.  We can do this:</p>
<pre class="doctest-block">
&gt;&gt;&gt; from pyparsing import OneOrMore
&gt;&gt;&gt; multiple = OneOrMore(hex_num)
&gt;&gt;&gt; multiple.parseString('1f')
(['1f'], {})
&gt;&gt;&gt; multiple.parseString('1f 2f 3f')
(['1f', '2f', '3f'], {})
</pre>
</div>
<div class="section">
<h2><a id="parse-actions" name="parse-actions">Parse actions</a></h2>
<p>Parse actions are functions that are run on parsed tokens; generally,
the result of the parse action replaces the parsed token.  For example,</p>
<pre class="doctest-block">
&gt;&gt;&gt; def convert_hex(x):
...   return eval('0x' + x[0])
&gt;&gt;&gt; hex_num = hex_num.setParseAction(convert_hex).setResultsName('num')
&gt;&gt;&gt; result = hex_num.parseString('1f')
&gt;&gt;&gt; print result.num
31
</pre>
<p>As you can see, this sort of parse function allows you to convert
parse results into objects automagically (after all, there's no reason
that <tt class="docutils literal"><span class="pre">convert_hex</span></tt> needs to return an integer; it could return an object
of any type).</p>
</div>
<div class="section">
<h2><a id="defining-convenient-and-re-usable-parse-objects" name="defining-convenient-and-re-usable-parse-objects">Defining convenient and re-usable parse objects</a></h2>
<p>This brings us to a &quot;putting it all together&quot; moment: suppose that you
have some kind of string that turns up throughout the string you're
parsing.  For the parser I was working on, one common string was an
expectation value (i.e. a floating point number).  This was no
<em>ordinary</em> floating point number, though: it <em>could</em> start with 'e', which
meant that you needed to prepend a '1'.  For example,</p>
<pre class="literal-block">
1.0  ==&gt;  1.0
1e-5 ==&gt;  1e-5
e-5  ==&gt;  1e-5
</pre>
<p>Well, the first obvious way to handle this is like so:</p>
<pre class="doctest-block">
&gt;&gt;&gt; from pyparsing import Word, nums
&gt;&gt;&gt; e_val = Word(nums + &quot;e-&quot;)
&gt;&gt;&gt; def convert_eval(x):
...    e = x[0]
...    if e.startswith('e'): e = '1' + e
...    return float(e)
&gt;&gt;&gt; e_val = e_val.setParseAction(convert_eval)
&gt;&gt;&gt; e_val.parseString('e-5')
([1.0000000000000001e-05], {})
</pre>
<p>OK, that's acceptable, but ugly if you have lots of e_val's floating around.</p>
<p>You could refine things by naming your expectation values when they occur:</p>
<pre class="doctest-block">
&gt;&gt;&gt; e_val_1 = e_val.setResultsName('e_val_1')
&gt;&gt;&gt; e_val_2 = e_val.setResultsName('e_val_2')
&gt;&gt;&gt; results = (e_val_1 + e_val_2).parseString('1e-3 5.0')
&gt;&gt;&gt; results.e_val_1
0.001
&gt;&gt;&gt; results.e_val_2
5.0
</pre>
<p>...but that's still a lot of code.  Here's the suggestion that Paul made
to me when he first saw my hacked-together parser:</p>
<pre class="doctest-block">
&gt;&gt;&gt; e_val = Word(nums + &quot;e-&quot;)
&gt;&gt;&gt; def named_e_val(name):
...    x = Word(nums + &quot;e-&quot;).setParseAction(convert_eval).copy()
...    x = x.setResultsName(name)
...    return x
</pre>
<p>Now I can just say</p>
<pre class="doctest-block">
&gt;&gt;&gt; grammar = named_e_val('e_val_1') + named_e_val('e_val_2')
&gt;&gt;&gt; results = grammar.parseString('1e-3 5.0')
&gt;&gt;&gt; results.e_val_1
0.001
&gt;&gt;&gt; results.e_val_2
5.0
</pre>
</div>
</div>
<div class="section">
<h1><a id="building-a-blast-output-parser" name="building-a-blast-output-parser">Building a BLAST output parser</a></h1>
<p>Now on to my real problem: building an output parser for NCBI BLAST.</p>
<p>Briefly, NCBI BLAST is a very widely used sequence search algorithm,
and it has a notoriously annoying set of output formats.  The most
annoying thing about the output is that only the human-intended
output contains a full set of information, so you need to parse something
that has been formatted for humans.</p>
<p>Another annoying thing about the output format is that it changes regularly
in subtle ways.  This means that most BLAST parsers break at least once a
year.</p>
<div class="section">
<h2><a id="why-did-i-choose-pyparsing" name="why-did-i-choose-pyparsing">Why did I choose pyparsing?</a></h2>
<p>I chose pyparsing for this project partly because I am using it for
twill, and it worked quite well there. However, the main decision
point was that I needed to make a <em>readable</em> and <em>maintainable</em>
parser, so that down the road I wouldn't have to relearn all sorts of
nasty syntax in order to update the parser when NCBI changed their
output formats.  pyparsing seemed to fit that bill.</p>
</div>
<div class="section">
<h2><a id="what-kind-of-output-do-i-need-to-deal-with" name="what-kind-of-output-do-i-need-to-deal-with">What kind of output do I need to deal with?</a></h2>
<p>So, how bad is the output?  Well, here's an example:</p>
<pre class="literal-block">
&gt;ref|NP_598432.1| U2 small nuclear ribonucleoprotein auxiliary factor (U2AF) 2 [Mus
           musculus]
          Length = 306

 Score =  394 bits (1013), Expect = e-110
 Identities = 202/279 (72%), Positives = 222/279 (79%)
 Frame = -1

Query: 888 FLNNQMKLAGLAQAPGNPVLAVQITWDKNFSSLEFRSVDETTQALAFDGIIFQGQSLKLR 709
           F N QM+L GL QAPGNPVLAVQI  DKNF+ LEFRSVDETTQA+AFDGIIFQGQSLK+R
Sbjct: 3   FFNAQMRLGGLTQAPGNPVLAVQINQDKNFAFLEFRSVDETTQAMAFDGIIFQGQSLKIR 62

Query: 708 RPHDYQPLPGMSESPALHVPVGVVSTVVQDTPHKLFIGGLPSYLTDDQVKELLTSFGPLK 529
           RPHDYQPLPGMSE+P+++VP GVVSTVV D+ HKLFIGGLP+YL DDQVKELLTSFGPLK
Sbjct: 63  RPHDYQPLPGMSENPSVYVP-GVVSTVVPDSAHKLFIGGLPNYLNDDQVKELLTSFGPLK 121

Query: 528 AFNLVKDSATCFSKGYAFCEYADVNVTDQAIAGLNGMQLGDKKLIVQRASVGAKNANXXX 349
           AFNLVKDSAT  SKGYAFCEY D+NVTDQAIAGLNGMQLGDKKL+VQRASVGAKNA
Sbjct: 122 AFNLVKDSATGLSKGYAFCEYVDINVTDQAIAGLNGMQLGDKKLLVQRASVGAKNATLST 181

Query: 348 XXXXXXXXXXPGLASSQVQHSGLPTEVLCLMNMVTPXXXXXXXXXXXXXXXXXXECGKYG 169
                     PGL SSQVQ  G PTEVLCLMNMV P                  EC KYG
Sbjct: 182 INQTPVTLQVPGLMSSQVQMGGHPTEVLCLMNMVLPEELLDDEEYEEIVEDVRDECSKYG 241

Query: 168 SVRSVEIPRPVNGLDIPGCGKIFVEFASLLDCQRAQQAL 52
            V+S+EIPRPV+G+++PGCGKIFVEF S+ DCQ+A Q L
Sbjct: 242 LVKSIEIPRPVDGVEVPGCGKIFVEFTSVFDCQKAMQGL 280
</pre>
<p>Lots of finicky things to parse in there, eh?  Let's focus on the score:</p>
<pre class="literal-block">
Score =  394 bits (1013), Expect = e-110
Identities = 202/279 (72%), Positives = 222/279 (79%)
Frame = -1
</pre>
</div>
<div class="section">
<h2><a id="my-first-iteration" name="my-first-iteration">My first iteration</a></h2>
<p>Here's my first set of code:</p>
<pre class="literal-block">
self.score = Literal(&quot;Score =&quot;).suppress() +
 Word(nums + &quot;.&quot;).setParseAction(make_float).setResultsName('bits') +
        Literal(&quot;bits (&quot;).suppress() +
 Word(nums).setParseAction(make_int).setResultsName('bits_max') +
        Literal(&quot;),&quot;).suppress() +
        Word(&quot;Expect()&quot; + nums).suppress() + Literal(&quot;=&quot;) +
 Word(e_val).setParseAction(make_float).setResultsName('expect') +
        Literal(&quot;Identities =&quot;).suppress() + identities +
        Optional(Literal(&quot;Positives =&quot;).suppress() + positives) +
        Optional(Literal(&quot;Gaps =&quot;).suppress() + gaps) +
        Optional((Literal(&quot;Frame =&quot;).suppress() +
        Word(frame).setParseAction(make_int).setResultsName('frame1') +
        Optional(Literal(&quot;/&quot;).suppress() +
 Word(frame).setParseAction(make_int).setResultsName('frame2'))) |
        (Literal(&quot;Strand =&quot;) + restOfLine))
</pre>
<p>What can I say?  It worked...</p>
</div>
<div class="section">
<h2><a id="what-it-looked-like-after-paul-s-suggestions" name="what-it-looked-like-after-paul-s-suggestions">What it looked like after Paul's suggestions</a></h2>
<p>I sent the above on to Paul, and after some gagging, he sent me back a bunch
of suggestions.  I ended up with this:</p>
<pre class="literal-block">
self.score = Literal(&quot;Score =&quot;) + named_float('bits') +
        &quot;bits (&quot; + named_int('bits_max') + &quot;),&quot; +
        Word(&quot;Expect()&quot; + nums) + &quot;=&quot; + named_float('expect') +
        &quot;Identities =&quot; + identities +
        Optional(&quot;Positives =&quot; + positives) +
        Optional(&quot;Gaps =&quot; + gaps) +
        Optional((&quot;Frame =&quot; + named_frame('frame1') +
          Optional(&quot;/&quot; + named_frame('frame2'))) |
                 (&quot;Strand =&quot; + restOfLine))
</pre>
<p>This is clearly much friendler to read!</p>
<p>I would also like to note that this kind of refactoring is tricky to do
without being able to test each subset of the parse grammar.  pyparsing
let me break the parse grammar down into subsets in a very nice and
convenient way, which really helped with testing.</p>
</div>
<div class="section">
<h2><a id="a-sort-of-conclusion" name="a-sort-of-conclusion">A sort of conclusion</a></h2>
<p>My parsing code is basically a generator wrapped around pyparsing
results; here's what the <tt class="docutils literal"><span class="pre">blastparser</span></tt> API looks like:</p>
<pre class="literal-block">
for record in parse_file('blast_output.txt'):
   print '-', record.query_name, record.database.name
   for hit in record.hits:
      print '--', hit.subject_name, hit.subject_length
      print '  ', hit.total_score, hit.total_expect
      for submatch in hit:
         print submatch.expect, submatch.bits

         print submatch.query_sequence
         print submatch.alignment
         print submatch.subject_sequence
</pre>
<p>Because I use parse actions to turn each block into an object, it's really
a very thin layer.</p>
</div>
<div class="section">
<h2><a id="future-thoughts" name="future-thoughts">Future thoughts</a></h2>
<p>Speed.  Speed speed speed speed.  How can I speed things up?</p>
<p>Without profiling, I'm not sure where the bottlenecks are, and that
should probably be my first step.  Nonetheless, I'm planning to try
out lazy evaluation, which would work something like this.</p>
<p>First, define the block structure:</p>
<pre class="doctest-block">
&gt;&gt;&gt; from pyparsing import SkipTo
&gt;&gt;&gt; complex_block = &quot;&quot;&quot;
... SOMETHING
... SOMETHING ELSE
... END
... MORE STUFF THAT MATTERS
... &quot;&quot;&quot;
&gt;&gt;&gt; end_marker = SkipTo(&quot;END&quot;, include=True).suppress()
</pre>
<p>Build a grammar for the internal structure:</p>
<pre class="doctest-block">
&gt;&gt;&gt; internal_grammar = &quot;...&quot;
</pre>
<p>Define a lazy evaluation class:</p>
<pre class="doctest-block">
&gt;&gt;&gt; class LazyParse:
...    def __init__(self, text):
...       self.text = text
...       self.parsed = None
...    def parse(self):
...       if self.parsed:
...          return self.parsed
...       self.parsed = internal_grammar.parseString(self.text)
...       return self.parsed
</pre>
<p>Then, set a parse action:</p>
<pre class="doctest-block">
&gt;&gt;&gt; def parse_complex_block(x):
...   return LazyParse(x[0])
&gt;&gt;&gt; end_marker = end_marker.setParseAction(parse_complex_block)
</pre>
<p>and Bob's your uncle... but I haven't gotten all the mechanics worked out.</p>
</div>
</div>
</div>
</body>
</html>
